Anatomy of 16 byte cache


Cache Replacement

Block must be aligned in memory


4 byte block to match word size

Simpler ->
    Ask 4 byte boundaries to be aligned in memory
    - 00 always last two bits address
        - compare 30 bits, so two fewer bits 
    
Anatomy of 32B cache, 8 byte block
    - 3 bits of addresses always 000
    - tags have even numbered words

Fully associative cache
    - every tag is checked on ever access
        - any location in memory could live in any memory in cache
        - would need to search all locations

Optimization: 2 sets 
    => 1/2 comparators 

    - top cache
    - bottom cache

1 Address bit selects which set


Address fields used by cache controller:
1) Block Offset
2) Set Index
    which set of cache looking in right now
3) Tag
    actual tag bits need to compare

Direct mapped design
    where only one tag to need to compare in a single set

